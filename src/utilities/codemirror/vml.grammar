// VML - Virtual Machine Language
// Based on 2.0.11 SIS

// A module is a set of functions (absolute sequences, relative sequences, and blocks) and
// optional variable definitions. There may be one or more functions in a module. Typically,
// a module either contains one function (e.g. a master sequence, a special-purpose relative
// sequence, or a special-purpose block), or it contains a set of general-purpose blocks
// stored together for convenience and known as a library.

// Exactly one module exists per source file. A module is bounded
// by the keywords MODULE and END_MODULE. Comments may appear before and
// after the module portion of the file, and anywhere between the keywords.

// VML is not case sensitive: case is ignored. All keywords and symbols may be in upper and/or lower case.
// It is recommended that keywords (like MODULE and BLOCK) be placed in upper case, and that symbols which
// the user has control over be placed in lower case. This upper case / lower case convention is followed
// throughout this document.

// Grammar implementation notes
// Token and rule names are taken from VMLCOMP 2.0.11 Interface Specification and then capitalized
// since code mirror does not create tree nodes for lower case names.

// TODOs
// * figure out what vml_create_default(0) means
// * confirm if order is strict on flags
// * vml_create_range ?
// * see if multiple ranges are allowed INPUT INT mode := 3 VALUES 1..6, 8..9
// * Confirm EXTERNAL_CALL if there's comma after simple expression before call parameters
// * Are assignments allowed in external_call parameters
// * Confirm if keywords are case sensitive
// * vml_utils_check_for_keyword
// * external tokenizer to support case insensitive keywords
// https://github.com/lezer-parser/generator/blob/10a697a11ebdef98cd08a2c6ac2ef6619604385c/test/cases/ExternalSpecializer.txt#L9
// https://github.com/lezer-parser/css/blob/692710b42f83961151eee4cf73b0ae18ebccffad/src/tokens.js#L35
// https://github.com/lezer-parser/css/blob/692710b42f83961151eee4cf73b0ae18ebccffad/src/css.grammar#L147

@skip { space | Comment }

@top Text_file {
  optional_end_lines
  MODULE
  End_lines
  Optional_static_variable_section {
    VARIABLES
    End_lines
    Variable_declarations_with_optional_tlm_ids
    END_VARIABLES
    End_lines
  }?
  Functions {
    Function*
  }
  END_MODULE
  End_lines
}

End_lines {
  END_OF_LINE+
}

optional_end_lines {
  End_lines?
}

Function {
  Block
  | Relative_sequence
  | Absolute_Sequence
  | Sequence
}

Block {
  BLOCK
  Common_Function
}

Relative_sequence {
  RELATIVE_SEQUENCE
  Common_Function
}

Absolute_Sequence {
  ABSOLUTE_SEQUENCE
  Common_Function
}

Sequence {
  SEQUENCE
  Common_Function
}

Function_name { SYMBOL_CONST }

Common_Function {
  Function_name End_lines
  Parameters
  Flags {
    FLAGS
    Flags_symbols {
      // Confirm if order is strict
      AUTOEXECUTE?
      AUTOUNLOAD?
      REENTRANT?
    }
    End_lines
  }?
  Variable_declarations {
    Variable_declaration*
  }
  Body {
    BODY
    End_lines
    Time_tagged_statements {
      Time_tagged_statement {
        TIME_CONST
        Statement
      }*
    }
    END_BODY
    End_lines
  }
}

Statement {
  statement_no_endline {
    Issue
    | Issue_dynamic
    | Issue_hex
    | Noop
    | Clear
    | Assignment
    | Simple_call
    | External_call
    | For_statement
    | End_for
    | Label
    | Flow
    | Vm_management

    | If
    | Else_if
    | Else
    | End_if

    | While
    | End_while
  }
  End_lines
}

Noop {
  NOOP
}

Clear {
  CLEAR
}

Issue {
  ISSUE
  // Function_name, Call_parameters not shown in schema
  Function_name
  Call_parameters
}

// Some examples include commas between arguments
Issue_dynamic {
  ISSUE_DYNAMIC
  // Function_name not shown in schema
  Function_name
  Call_parameters
}

// Issue_no_time {
// incomplete in schema
// }

Parameters {
  Parameter*
}

Parameter {
  Input_parameter {
    INPUT
    Data_kind?
    Variable_name
    Optional_default_input_value?
    Optional_value_list?
    End_lines
  }
  | Input_output_parameter {
    INPUT_OUTPUT
    Data_kind?
    Variable_name
    Optional_default_input_value?
    Optional_value_list?
    End_lines
  }
}

Optional_default_input_value {
  (
    ASSIGNMENT
    Constant
  )
}

Optional_value_list {
  VALUES
  Input_value
  (COMMA Input_value)*
}

// input_value: range {vml_create_range(1, 0);} | constant {vml_create_default(0);};
Input_value {
  Constant
  | Input_Range {
    INT_RANGE_CONST
  }
}

Variable_declaration {
  DECLARE
  Variable_declaration_type
  End_lines
}

Variable_name { SYMBOL_CONST }

Variable_declarations_with_optional_tlm_ids {
  Variable_declaration_with_optional_tlm_id {
    DECLARE
    EXTERNAL?
    READ_ONLY?
    Variable_declaration_type
    (TLM_ID Tlm_id_const {
      INT_CONST
      | UINT_CONST
      | DEFINED_SYMBOL_CONST
    })?
    End_lines
  }+
}

Variable_declaration_type {
  Variable_name_constant {
    Data_kind
    Variable_name
    ASSIGNMENT
    Constant
  }
}

Data_kind {
  INT
  | UINT
  | LOGICAL
  | DOUBLE
  | STRING
  | UNKNOWN
  | TIME
  | ABSOLUTE_TIME
  | RELATIVE_TIME
}

Constant {
  INT_CONST
  | (UINT_CONST | HEX_CONST)
  | DOUBLE_CONST
  | STRING_CONST
  | UNKNOWN_CONST
  | Boolean
  | TIME_CONST
  | DEFINED_SYMBOL_CONST
}

Boolean {
  True_const
  | False_const
}

True_const { TRUE_CONST }
False_const { FALSE_CONST }

UNKNOWN_CONST {
  UNKNOWN
}

TIME_CONST {
  Full_or_spacecraft_or_day_or_short_time {
    Full_time_const { FULL_TIME_CONST }
    | Day_time_const { DAY_TIME_CONST }
    | Short_time_const { SHORT_TIME_CONST }
    | Spacecraft_time_const { SPACECRAFT_TIME_CONST }
  }
}

Issue_hex {
  ISSUE_HEX
  Hex_const
  Issue_hex_values
}

Issue_hex_no_time {
  ISSUE_HEX
  Hex_const
  Issue_hex_values
}

Issue_hex_values { Issue_hex_value* }
Issue_hex_value { HEX_CONST }
Hex_const { HEX_CONST }

Assignment {
  Variable_name
  ASSIGNMENT
  Assignment_source {
// | issue_no_time
    Issue_hex_no_time
// | external_call_no_time
    | Compound_expr
    | Simple_call_no_time
    | Wait
    | Test_and_set
  }
}

External_call {
  EXTERNAL_CALL
  Simple_expr
  Call_parameters
}

External_call_no_time {
  EXTERNAL_CALL
  Simple_expr
  Call_parameters
}

Tlm_id_const {
  INT_CONST | UINT_CONST | DEFINED_SYMBOL_CONST
}

Call_parameters {
  (
    Call_parameter
    (COMMA Call_parameter)*
  )?
}

Call_parameter {
  Simple_expr
}

Simple_call {
  CALL
  Function_name
  Call_parameters
}

Simple_call_no_time {
  CALL
  Function_name
  Call_parameters
}

Compound_expr_base {
  Simple_expr
  | Unop Simple_expr
  | Built_in_function
}

Compound_expr_mid {
  Compound_expr_base
  | (OPEN_PAREN Compound_expr CLOSE_PAREN)
}

Compound_expr {
  Compound_expr_mid
  | (Compound_expr_mid Binop Compound_expr)
}

Simple_expr {
  Constant
  | Variable_name
}

Unop {
  LOGICAL_NOT
  // | BIT_INVERT
  | BIT_NOT

  // | Subtract
}

Built_in_function {
  // Grammar shows 2 sets of paranthesis
  (Zero_parm_built_in_function_name OPEN_PAREN CLOSE_PAREN)
  | (Unary_parm_built_in_function_name OPEN_PAREN Compound_expr CLOSE_PAREN)
}

Zero_parm_built_in_function_name {
  SPACECRAFT_TIME
  // Odd to not have a name???
  OPEN_PAREN CLOSE_PAREN
}

Unary_parm_built_in_function_name {
  Simple_coerce
  | Trig
  | LENGTH
  | ABS
}

Simple_coerce {
  INT_COERCE
  | UINT_COERCE
  | LOGICAL_COERCE
  | DOUBLE_COERCE
  | STRING_COERCE
  | TIME_COERCE
  | UNKNOWN_COERCE
}

Trig {
  SIN
  | COS
  | TAN
  | ASIN
  | ACOS
  | ATAN
}

Binop {
  Arith_binop
  | Bit_binop
  | Comparison_binop
  | Logical_binop
  | String_binop
}

Arith_binop {
  ADD
  | SUBTRACT
  | MULTIPLY
  | DIVIDE
  | MODULO
  | POWER
}

Bit_binop {
  BIT_AND
  | BIT_OR
  | BIT_XOR
  | SHIFT_LEFT
  | SHIFT_RIGHT
}

Comparison_binop {
  EQUAL
  | NOT_EQUAL
  | LESS
  | LESS_OR_EQUAL
  | GREATER
  | GREATER_OR_EQUAL
}

Logical_binop {
  LOGICAL_AND
  | LOGICAL_OR
  | LOGICAL_XOR
}

String_binop {
  CONCAT | SPLIT_LEFT | SPLIT_RIGHT
}

Wait_comparison_binop {
  EQUAL
  | NOT_EQUAL
  | LESS
  | LESS_OR_EQUAL
  | GREATER
  | GREATER_OR_EQUAL
}

Wait {
  Wait_simple
  | Wait_change
  | Wait_compare
}

Wait_simple {
  WAIT
  Variable_name
  Optional_timeout?
}

Wait_change {
  WAIT_CHANGE
  Variable_name
  Optional_timeout?
}

Wait_compare {
  WAIT
  Variable_name
  Wait_comparison_binop
  Simple_expr
  Optional_timeout?
}

Optional_timeout {
  TIMEOUT
  Simple_expr // not shown in example
}

Test_and_set {
  TEST_AND_SET
  Variable_name
  Optional_timeout
}

Label {
  LABEL
  Label_name
}

Label_name { SYMBOL_CONST }

Flow {
  Branch
  | Return
  | Delay
}

Branch { Branch_always | Branch_true | Branch_false }

Branch_always {
  BRANCH
  Label_name
}

Branch_true {
  BRANCH_TRUE
  Simple_expr
  Label_name
}

Branch_false {
  BRANCH_FALSE
  Simple_expr
  Label_name
}

If {
  IF
  If_condition
  // not shown in grammar
  THEN
}

Else_if {
  ELSE_IF
  If_condition
  // not shown in grammar
  THEN
}

Else {
  ELSE
}

End_if {
  END_IF
}

If_condition {
  Compound_expr
}

While {
  WHILE
  While_condition {
    Compound_expr
  }
  DO // not shown in grammar, but in example
}

End_while {
  END_WHILE
}

For_statement {
  FOR
  For_assignment
  For_bound
  Optional_step {
    STEP Compound_expr
  }?
  DO
}

End_for {
  END_FOR
}

For_assignment {
  Variable_name
  ASSIGNMENT
  Compound_expr
}

For_bound {
  For_direction {
    (TO | DOWN_TO)
  }
  Compound_expr
}

Return {
  RETURN
  Simple_expr
}

Delay {
  Delay_by {
    DELAY_BY
    Simple_expr
  }
  | Delay_until {
    DELAY_UNTIL
    Simple_expr
  }
}

Vm_management { Halt | Pause | Resume | Spawn }

Halt {
  HALT
  Simple_expr
}

Pause {
  PAUSE
  Simple_expr
}

Resume {
  RESUME
  Simple_expr
}

Spawn {
  SPAWN
  Simple_expr
  Function_name
  Call_parameters
}

// VMLmodulelexerconstructs
ABS { @specialize<SYMBOL_CONST, "ABS"> }
ABSOLUTE_SEQUENCE { @specialize<SYMBOL_CONST, "ABSOLUTE_SEQUENCE"> }
ABSOLUTE_TIME { @specialize<SYMBOL_CONST, "ABSOLUTE_TIME"> }
ACOS { @specialize<SYMBOL_CONST, "ACOS"> }
ASIN { @specialize<SYMBOL_CONST, "ASIN"> }
ATAN { @specialize<SYMBOL_CONST, "ATAN"> }
AUTOEXECUTE { @specialize<SYMBOL_CONST, "AUTOEXECUTE"> }
AUTOUNLOAD { @specialize<SYMBOL_CONST, "AUTOUNLOAD"> }
BIT_INVERT { @specialize<SYMBOL_CONST, "BIT_INVERT"> }
BLOCK { @specialize<SYMBOL_CONST, "BLOCK"> }
BODY { @specialize<SYMBOL_CONST, "BODY"> }
BRANCH { @specialize<SYMBOL_CONST, "BRANCH"> }
BRANCH_FALSE { @specialize<SYMBOL_CONST, "BRANCH_FALSE"> }
BRANCH_TRUE { @specialize<SYMBOL_CONST, "BRANCH_TRUE"> }
CALL { @specialize<SYMBOL_CONST, "CALL"> }
CLEAR { @specialize<SYMBOL_CONST, "CLEAR"> }
CONCAT { @specialize<SYMBOL_CONST, "CONCAT"> }
COS { @specialize<SYMBOL_CONST, "COS"> }
DECLARE { @specialize<SYMBOL_CONST, "DECLARE"> }
DEFINED_SYMBOL_CONST { @specialize<SYMBOL_CONST, "DEFINED_SYMBOL_CONST"> }
DELAY_BY { @specialize<SYMBOL_CONST, "DELAY_BY"> }
DELAY_UNTIL { @specialize<SYMBOL_CONST, "DELAY_UNTIL"> }
DO { @specialize<SYMBOL_CONST, "DO"> }
DOUBLE { @specialize<SYMBOL_CONST, "DOUBLE"> }
DOUBLE_COERCE { @specialize<SYMBOL_CONST, "DOUBLE_COERCE"> }
DOWN_TO { @specialize<SYMBOL_CONST, "DOWN_TO"> }
ELSE { @specialize<SYMBOL_CONST, "ELSE"> }
ELSE_IF { @specialize<SYMBOL_CONST, "ELSE_IF"> }
END_BODY { @specialize<SYMBOL_CONST, "END_BODY"> }
END_FOR { @specialize<SYMBOL_CONST, "END_FOR"> }
END_IF { @specialize<SYMBOL_CONST, "END_IF"> }
END_MODULE { @specialize<SYMBOL_CONST, "END_MODULE"> }
END_VARIABLES { @specialize<SYMBOL_CONST, "END_VARIABLES"> }
END_WHILE { @specialize<SYMBOL_CONST, "END_WHILE"> }
EXTERNAL { @specialize<SYMBOL_CONST, "EXTERNAL"> }
EXTERNAL_CALL { @specialize<SYMBOL_CONST, "EXTERNAL_CALL"> }
FALSE_CONST { @specialize<SYMBOL_CONST, "FALSE_CONST"> }
FLAGS { @specialize<SYMBOL_CONST, "FLAGS"> }
FOR { @specialize<SYMBOL_CONST, "FOR"> }
HALT { @specialize<SYMBOL_CONST, "HALT"> }
IF { @specialize<SYMBOL_CONST, "IF"> }
INPUT { @specialize<SYMBOL_CONST, "INPUT"> }
INPUT_OUTPUT { @specialize<SYMBOL_CONST, "INPUT_OUTPUT"> }
INT { @specialize<SYMBOL_CONST, "INT"> }
INT_COERCE { @specialize<SYMBOL_CONST, "INT_COERCE"> }
ISSUE { @specialize<SYMBOL_CONST, "ISSUE"> | @specialize<SYMBOL_CONST, "issue"> }
ISSUE_DYNAMIC { @specialize<SYMBOL_CONST, "ISSUE_DYNAMIC"> }
ISSUE_HEX { @specialize<SYMBOL_CONST, "ISSUE_HEX"> }
LABEL { @specialize<SYMBOL_CONST, "LABEL"> }
LENGTH { @specialize<SYMBOL_CONST, "LENGTH"> }
LOGICAL { @specialize<SYMBOL_CONST, "LOGICAL"> }
LOGICAL_COERCE { @specialize<SYMBOL_CONST, "LOGICAL_COERCE"> }
MODULE { @specialize<SYMBOL_CONST, "MODULE"> }
NOOP { @specialize<SYMBOL_CONST, "NOOP"> }
PAUSE { @specialize<SYMBOL_CONST, "PAUSE"> }
READ_ONLY { @specialize<SYMBOL_CONST, "READ_ONLY"> }
REENTRANT { @specialize<SYMBOL_CONST, "REENTRANT"> }
RELATIVE_SEQUENCE { @specialize<SYMBOL_CONST, "RELATIVE_SEQUENCE"> }
RELATIVE_TIME { @specialize<SYMBOL_CONST, "RELATIVE_TIME"> }
RESUME { @specialize<SYMBOL_CONST, "RESUME"> }
RETURN { @specialize<SYMBOL_CONST, "RETURN"> }
SEQUENCE { @specialize<SYMBOL_CONST, "SEQUENCE"> }
SIN { @specialize<SYMBOL_CONST, "SIN"> }
SPACECRAFT_TIME { @specialize<SYMBOL_CONST, "SPACECRAFT_TIME"> }
SPAWN { @specialize<SYMBOL_CONST, "SPAWN"> | @specialize<SYMBOL_CONST, "spawn"> }
STEP { @specialize<SYMBOL_CONST, "STEP"> }
STRING { @specialize<SYMBOL_CONST, "STRING"> }
STRING_COERCE { @specialize<SYMBOL_CONST, "STRING_COERCE"> }
SYNTAX_ERROR { @specialize<SYMBOL_CONST, "."> }
TAN { @specialize<SYMBOL_CONST, "TAN"> }
TEST_AND_SET { @specialize<SYMBOL_CONST, "TEST_AND_SET"> }
THEN { @specialize<SYMBOL_CONST, "THEN"> }
TIME { @specialize<SYMBOL_CONST, "TIME"> }
TIME_COERCE { @specialize<SYMBOL_CONST, "TIME_COERCE"> }
TIMEOUT { @specialize<SYMBOL_CONST, "TIMEOUT"> }
TLM_ID { @specialize<SYMBOL_CONST, "TLM_ID"> }
TO { @specialize<SYMBOL_CONST, "TO"> }
TRUE_CONST { @specialize<SYMBOL_CONST, "TRUE_CONST"> }
UINT { @specialize<SYMBOL_CONST, "UINT"> }
UINT_COERCE { @specialize<SYMBOL_CONST, "UINT_COERCE"> }
UNKNOWN { @specialize<SYMBOL_CONST, "UNKNOWN"> }
UNKNOWN_COERCE { @specialize<SYMBOL_CONST, "UNKNOWN_COERCE"> }
VALUES { @specialize<SYMBOL_CONST, "VALUES"> }
VARIABLES { @specialize<SYMBOL_CONST, "VARIABLES"> }
WAIT { @specialize<SYMBOL_CONST, "WAIT"> }
WAIT_CHANGE { @specialize<SYMBOL_CONST, "WAIT_CHANGE"> }
WHILE { @specialize<SYMBOL_CONST, "WHILE"> }

// grammar shows "&", but example uses "BIT_AND"
BIT_AND {
  BIT_AND_OP
  | @specialize<SYMBOL_CONST, "BIT_AND">
}

BIT_NOT {
  BIT_INVERT
  | BIT_INVERT_OP
  // not in grammar, but in example
  | @specialize<SYMBOL_CONST, "BIT_NOT">
}

// not in grammar, but in example
LOGICAL_NOT {
  LOGICAL_NOT_OP
  | @specialize<SYMBOL_CONST, "LOGICAL_NOT">
}

@tokens {
  space { $[ \t]+ }
  Comment { ";" ![\n]* }

  // check if mix case is allowed
  SYMBOL_CONST { @asciiLetter (@asciiLetter| @digit | "_" | "-")* }

  ASSIGNMENT { ":=" }
  OPEN_PAREN { "(" }
  CLOSE_PAREN { ")" }

  ADD { "+" }
  SUBTRACT { "-" }
  MULTIPLY { "*" }
  DIVIDE { "/" }
  MODULO { "%" }
  POWER { "^" }

  EQUAL { "=""="? }
  NOT_EQUAL { "!=" }
  GREATER {">"}
  GREATER_OR_EQUAL {">="}
  LESS {"<"}
  LESS_OR_EQUAL {"<="}

  BIT_INVERT_OP { "~" }
  BIT_AND_OP { "&" }
  BIT_OR { "|" }
  BIT_XOR { "@" }
  SHIFT_LEFT { "<<" }
  SHIFT_RIGHT { ">>" }

  LOGICAL_NOT_OP {"!"}
  LOGICAL_AND {"&&"}
  LOGICAL_OR {"||"}
  LOGICAL_XOR {"@@"}

  // CONCAT { "CONCAT" }
  SPLIT_LEFT { "-|" }
  SPLIT_RIGHT { "|-" }

  FULL_TIME_CONST {
    $[aArR]@digit+"-"@digit+$[Tt]@digit+":"@digit+":"@digit+("."@digit+)?
  }

  DAY_TIME_CONST { // [r|R][0-9]+[t|T][0-9]+:[0-9]+:[0-9]+(\.[0-9]+)?
    $[rR]@digit+$[tT]@digit+":"@digit+":"@digit+("."@digit+)?
  }

  SHORT_TIME_CONST { // [r|R][0-9]+:[0-9]+:[0-9]+(\.[0-9]+)?
    $[rR]@digit+":"@digit+":"@digit+("."@digit+)?
  }

  SPACECRAFT_TIME_CONST {
    $[sS]@digit+"."@digit+
  }

  COMMA { "," }

  // Numbers

  INT_CONST {
    ("+" | "-")? @digit+
  }

  DOUBLE_CONST {
    ("+" | "-")?
    (
      (@digit+ "." @digit*)
      | ("." @digit+)
    )
  }

  UINT_CONST {
    @digit+ ("u" | "U")
  }

  HEX_CONST {
    "0" ("x" | "X") (@digit | $[a-f] | $[A-F])+
  }

  INT_RANGE_CONST {
    INT_CONST ".." INT_CONST
  }

  STRING_CONST { '"' (!["\\] | "\\" _)* '"' }

  @precedence { LESS_OR_EQUAL, SHIFT_LEFT, LESS }
  @precedence { GREATER_OR_EQUAL, SHIFT_RIGHT, GREATER }
  @precedence { INT_RANGE_CONST, DOUBLE_CONST, UINT_CONST, HEX_CONST, INT_CONST, ADD, SUBTRACT }
  @precedence { FULL_TIME_CONST, DAY_TIME_CONST, SHORT_TIME_CONST, SPACECRAFT_TIME_CONST, CONCAT, SYMBOL_CONST }

  END_OF_LINE { "\n" }
}
