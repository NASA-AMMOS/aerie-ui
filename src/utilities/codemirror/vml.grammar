// VML - Virtual Machine Language
// Based on 2.0.11 SIS

// TODOs
// * figure out what vml_create_default(0) means
// * confirm if order is strict on flags
// * vml_create_range ?
// * see if multiple ranges are allowed INPUT INT mode := 3 VALUES 1..6, 8..9
// * Confirm EXTERNAL_CALL if there's comma after simple expression before call parameters
// * Are assignments allowed in external_call parameters

@top Text_file {
  optional_end_lines {
    End_lines?
  }
  MODULE
  End_lines
  Optional_static_variable_section {
    VARIABLES
    End_lines
    Variable_declarations_with_optional_tlm_ids
    END_VARIABLES
    End_lines
  }?
  Functions {
    Function*
  }
  END_MODULE
  End_lines
}

@skip { space | Comment }

End_lines {
  END_OF_LINE+
}

Function {
  Block
  | AbsoluteSequence
}

AbsoluteSequence {
  ABSOLUTE_SEQUENCE
  Common_Function
}

Block {
  BLOCK
  Common_Function
}

Function_name { SYMBOL_CONST }

Common_Function {
  Function_name End_lines
  Parameters
  Flags {
    FLAGS
    Flags_symbols {
      // Confirm if order is strict
      AUTOEXECUTE?
      AUTOUNLOAD?
      REENTRANT?
    }
  }?
  Variable_declarations {
    Variable_declaration*
  }
  Body {
    BODY
    End_lines
    Time_tagged_statements {
      Time_tagged_statement {
        TIME_CONST
        Statement
      }*
    }
    END_BODY
    End_lines
  }
}

Statement {
  statement_no_endline {
    Issue
// | issue_dynamic
// | issue_hex
    | Noop
    | Clear
    | Assignment
    | Simple_call
    | External_call
    | For
    | End_for
// | label
    | Flow
    | Vm_management

    | If
    | Else_if
    | Else
    | End_if

    | While
    | End_while
  }
  End_lines
}

Noop {
  NOOP
}

Clear {
  CLEAR
}

Issue {
  ISSUE
  // Call_parameters not shown in schema
  Call_parameters
}

Parameters {
  Parameter*
}

Parameter {
  Input_parameter {
    INPUT
    Data_kind?
    Variable_name ~ambigVariableName
    Optional_default_input_value?
    Optional_value_list?
    End_lines
  }
  // | Input_output_parameter
}

Optional_default_input_value {
  (
    ASSIGNMENT
    Constant
  )
}

Optional_value_list {
  VALUES
  Input_value
  (COMMA Input_value)*
}

// input_value: range {vml_create_range(1, 0);} | constant {vml_create_default(0);};
Input_value {
  Constant
  | Input_Range {
    INT_RANGE_CONST
  }
}

Variable_declaration {
  DECLARE
  Variable_declaration_type
  End_lines
}

Variable_name { SYMBOL_CONST }

Variable_declarations_with_optional_tlm_ids {
  Variable_declaration_with_optional_tlm_id {
    DECLARE
    EXTERNAL?
    READ_ONLY?
    Variable_declaration_type
    // (TLM_ID Tlm_id_const {
    //   INT_CONST
    //   | UINT_CONST
    //   // TODO defined symbol
    // })?
    End_lines
  }+
}

Variable_declaration_type {
  Variable_name_constant {
    Data_kind
    Variable_name ~ambigVariableName
    ASSIGNMENT
    Constant
  }
}

Data_kind {
  INT
  | UINT
  | LOGICAL
  | DOUBLE
  | STRING
  | UNKNOWN
  | TIME
  | ABSOLUTE_TIME
  | RELATIVE_TIME
}

Constant {
  INT_CONST
  | (UINT_CONST | HEX_CONST)
  | DOUBLE_CONST
  | STRING_CONST
  // Unknown_const |
  // Boolean |
  | TIME_CONST
  // DEFINED_SYMBOL_CONST
}

TIME_CONST {
  Full_or_spacecraft_or_day_or_short_time {
    Full_time_const { FULL_TIME_CONST }
    | Day_time_const { DAY_TIME_CONST }
    | Short_time_const { SHORT_TIME_CONST }
    | Spacecraft_time_const { SPACECRAFT_TIME_CONST }
  }
}

Assignment {
  Variable_name
  ASSIGNMENT
  Assignment_source {
// | issue_no_time
// | issue_hex_no_time
// | simple_call_no_time
// | external_call_no_time | wait
// | test_and_set;
    Compound_expr
    | Simple_call_no_time
    //
    | Wait
  }
}

External_call {
  EXTERNAL_CALL
  Simple_expr
  Call_parameters
}

External_call_no_time {
  EXTERNAL_CALL
  Simple_expr
  Call_parameters
}


// ...

Compound_expr_base {
  Simple_expr
  | (Unop Simple_expr)
  // | unop simple_expr
  // | built_in_function;
}

Compound_expr_mid {
  Compound_expr_base
  | (OPEN_PAREN Compound_expr CLOSE_PAREN)
}

Compound_expr {
  Compound_expr_mid
  | (Compound_expr_mid Binop Compound_expr)
}

Simple_expr {
  Constant
  | Variable_name
}

Unop {
  LOGICAL_NOT
  // | BIT_INVERT
  | BIT_NOT

  // | Subtract
}

Binop {
  Arith_binop
  | Bit_binop
  | Comparison_binop
  | Logical_binop
  | String_binop
}

Arith_binop {
  ADD
  | SUBTRACT
  | MULTIPLY
  | DIVIDE
  | MODULO
  | POWER
}

Bit_binop {
  BIT_AND
  | BIT_OR
  | BIT_XOR
  | SHIFT_LEFT
  | SHIFT_RIGHT
}

Comparison_binop {
  EQUAL
  | NOT_EQUAL
  | LESS
  | LESS_OR_EQUAL
  | GREATER
  | GREATER_OR_EQUAL
}

Logical_binop {
  LOGICAL_AND
  | LOGICAL_OR
  | LOGICAL_XOR
}

String_binop {
  CONCAT | SPLIT_LEFT | SPLIT_RIGHT
}

Wait_comparison_binop {
  EQUAL
  | NOT_EQUAL
  | LESS
  | LESS_OR_EQUAL
  | GREATER
  | GREATER_OR_EQUAL
}

Wait {
  Wait_simple
  | Wait_change
  | Wait_compare
}

Wait_simple {
  WAIT
  Variable_name
  Optional_timeout?
}

Wait_change {
  WAIT_CHANGE
  Variable_name
  Optional_timeout?
}

Wait_compare {
  WAIT
  Variable_name
  Wait_comparison_binop
  Simple_expr
  Optional_timeout?
}

Optional_timeout {
  TIMEOUT
  Simple_expr
  // not shown in example
}

Flow {
  // Branch |
  Return
  | Delay
}

If {
  IF
  If_condition
  // not shown in grammar
  THEN
}

Else_if {
  ELSE_IF
  If_condition
  // not shown in grammar
  THEN
}

Else {
  ELSE
}

End_if {
  END_IF
}

If_condition {
  Compound_expr
}

While {
  WHILE
  While_condition {
    Compound_expr
  }
  DO // DO is not in grammar, but in example
}

End_while {
  END_WHILE
}

For {
  FOR
  For_assignment
  For_bound
  Optional_step {
    STEP Compound_expr
  }?
  DO
}

End_for {
  END_FOR
}

For_assignment {
  Variable_name
  ASSIGNMENT
  Compound_expr
}

For_bound {
  For_direction {
    (TO | DOWN_TO)
  }
  Compound_expr
}

Return {
  RETURN
  Simple_expr
}

Tlm_id_const {
  ()
}

Call_parameters {
  (
    Call_parameter
    (COMMA Call_parameter)*
  )?
}

Call_parameter {
  Simple_expr
}


Simple_call {
  CALL
  Function_name
  Call_parameters
}

Simple_call_no_time {
  CALL
  Function_name
  Call_parameters
}

// ...


// delay: delay_by | delay_until; delay_by: DELAY_BY simple_expr; delay_until: DELAY_UNTIL simple_expr;
Delay {
  Delay_by {
    DELAY_BY
    Simple_expr
  }
  | Delay_until {
    DELAY_UNTIL
    Simple_expr
  }
}

Vm_management {
  Spawn
}

// Halt {

// }

// Pause {

// }

// Resume {

// }

Spawn {
  SPAWN
  Simple_expr
  Function_name
  Call_parameters
}

// VMLmodulelexerconstructs
ABS { @specialize<SYMBOL_CONST, "ABS"> }
ABSOLUTE_SEQUENCE { @specialize<SYMBOL_CONST, "ABSOLUTE_SEQUENCE"> }
ABSOLUTE_TIME { @specialize<SYMBOL_CONST, "ABSOLUTE_TIME"> }
AUTOEXECUTE { @specialize<SYMBOL_CONST, "AUTOEXECUTE"> }
AUTOUNLOAD { @specialize<SYMBOL_CONST, "AUTOUNLOAD"> }
BLOCK { @specialize<SYMBOL_CONST, "BLOCK"> }
BODY { @specialize<SYMBOL_CONST, "BODY"> }
CALL { @specialize<SYMBOL_CONST, "CALL"> }
CLEAR { @specialize<SYMBOL_CONST, "CLEAR"> }
CONCAT { @specialize<SYMBOL_CONST, "CONCAT"> }
DECLARE { @specialize<SYMBOL_CONST, "DECLARE"> }
DELAY_BY { @specialize<SYMBOL_CONST, "DELAY_BY"> }
DELAY_UNTIL { @specialize<SYMBOL_CONST, "DELAY_UNTIL"> }
DO { @specialize<SYMBOL_CONST, "DO"> }
DOUBLE { @specialize<SYMBOL_CONST, "DOUBLE"> }
DOWN_TO { @specialize<SYMBOL_CONST, "DOWN_TO"> }
ELSE { @specialize<SYMBOL_CONST, "ELSE"> }
ELSE_IF { @specialize<SYMBOL_CONST, "ELSE_IF"> }
END_BODY { @specialize<SYMBOL_CONST, "END_BODY"> }
END_FOR { @specialize<SYMBOL_CONST, "END_FOR"> }
END_IF { @specialize<SYMBOL_CONST, "END_IF"> }
END_MODULE { @specialize<SYMBOL_CONST, "END_MODULE"> }
END_VARIABLES { @specialize<SYMBOL_CONST, "END_VARIABLES"> }
END_WHILE { @specialize<SYMBOL_CONST, "END_WHILE"> }
EXTERNAL { @specialize<SYMBOL_CONST, "EXTERNAL"> }
EXTERNAL_CALL { @specialize<SYMBOL_CONST, "EXTERNAL_CALL"> }
FLAGS { @specialize<SYMBOL_CONST, "FLAGS"> }
FOR { @specialize<SYMBOL_CONST, "FOR"> }
HALT { @specialize<SYMBOL_CONST, "HALT"> }
IF { @specialize<SYMBOL_CONST, "IF"> }
INPUT { @specialize<SYMBOL_CONST, "INPUT"> }
INT { @specialize<SYMBOL_CONST, "INT"> }
ISSUE { @specialize<SYMBOL_CONST, "ISSUE"> }
LOGICAL { @specialize<SYMBOL_CONST, "LOGICAL"> }
MODULE { @specialize<SYMBOL_CONST, "MODULE"> }
NOOP { @specialize<SYMBOL_CONST, "NOOP"> }
READ_ONLY { @specialize<SYMBOL_CONST, "READ_ONLY"> }
REENTRANT { @specialize<SYMBOL_CONST, "REENTRANT"> }
RELATIVE_TIME { @specialize<SYMBOL_CONST, "RELATIVE_TIME"> }
RETURN { @specialize<SYMBOL_CONST, "RETURN"> }
SPAWN { @specialize<SYMBOL_CONST, "SPAWN"> }
STEP { @specialize<SYMBOL_CONST, "STEP"> }
STRING { @specialize<SYMBOL_CONST, "STRING"> }
THEN { @specialize<SYMBOL_CONST, "THEN"> }
TIME { @specialize<SYMBOL_CONST, "TIME"> }
TIMEOUT { @specialize<SYMBOL_CONST, "TIMEOUT"> }
TLM_ID { @specialize<SYMBOL_CONST, "TLM_ID"> }
TO { @specialize<SYMBOL_CONST, "TO"> }
UINT { @specialize<SYMBOL_CONST, "UINT"> }
UNKNOWN { @specialize<SYMBOL_CONST, "UNKNOWN"> }
VALUES { @specialize<SYMBOL_CONST, "VALUES"> }
VARIABLES { @specialize<SYMBOL_CONST, "VARIABLES"> }
WAIT { @specialize<SYMBOL_CONST, "WAIT"> }
WAIT_CHANGE { @specialize<SYMBOL_CONST, "WAIT_CHANGE"> }
WHILE { @specialize<SYMBOL_CONST, "WHILE"> }

// grammar shows "&", but example uses "BIT_AND"
BIT_AND {
  BIT_AND_OP
  | @specialize<SYMBOL_CONST, "BIT_AND">
}

// not in grammar, but in example
BIT_NOT {
  BIT_INVERT
  | @specialize<SYMBOL_CONST, "BIT_NOT">
}

@tokens {
  space { $[ \t]+ }
  Comment { ";" ![\n]* }

  // check if mix case is allowed
  SYMBOL_CONST { @asciiLetter (@asciiLetter| @digit | "_" | "-")* }

  ASSIGNMENT { ":=" }
  OPEN_PAREN { "(" }
  CLOSE_PAREN { ")" }

  ADD { "+" }
  SUBTRACT { "-" }
  MULTIPLY { "*" }
  DIVIDE { "/" }
  MODULO { "%" }
  POWER { "^" }

  EQUAL { "=""="? }
  NOT_EQUAL { "!=" }
  GREATER {">"}
  GREATER_OR_EQUAL {">="}
  LESS {"<"}
  LESS_OR_EQUAL {"<="}

  BIT_INVERT { "~" }
  BIT_AND_OP { "&" }
  BIT_OR { "|" }
  BIT_XOR { "@" }
  SHIFT_LEFT { "<<" }
  SHIFT_RIGHT { ">>" }

  LOGICAL_NOT {"!"}
  LOGICAL_AND {"&&"}
  LOGICAL_OR {"||"}
  LOGICAL_XOR {"@@"}

  // CONCAT { "CONCAT" }
  SPLIT_LEFT { "-|" }
  SPLIT_RIGHT { "|-" }

  FULL_TIME_CONST {
    $[aArR]@digit+"-"@digit+$[Tt]@digit+":"@digit+":"@digit+("."@digit+)?
  }

  DAY_TIME_CONST {
    // [r|R][0-9]+[t|T][0-9]+:[0-9]+:[0-9]+(\.[0-9]+)?
    $[rR]@digit+$[tT]@digit+":"@digit+":"@digit+("."@digit+)?
  }

  SHORT_TIME_CONST {
// [r|R][0-9]+:[0-9]+:[0-9]+(\.[0-9]+)?
    $[rR]@digit+":"@digit+":"@digit+("."@digit+)?
  }

  SPACECRAFT_TIME_CONST {
    $[sS]@digit+"."@digit+
  }

  COMMA { "," }

  // Numbers

  INT_CONST {
    ("+" | "-")? @digit+
  }

  DOUBLE_CONST {
    ("+" | "-")?
    (
      (@digit+ "." @digit*)
      | ("." @digit+)
    )
  }

  UINT_CONST {
    @digit+ ("u" | "U")
  }

  HEX_CONST {
    "0" ("x" | "X") (@digit | $[a-f] | $[A-F])+
  }

  INT_RANGE_CONST {
    INT_CONST ".." INT_CONST
  }

  STRING_CONST { '"' (!["\\] | "\\" _)* '"' }

  @precedence { LESS_OR_EQUAL, SHIFT_LEFT, LESS }
  @precedence { GREATER_OR_EQUAL, SHIFT_RIGHT, GREATER }
  @precedence { INT_RANGE_CONST, DOUBLE_CONST, UINT_CONST, HEX_CONST, INT_CONST, ADD, SUBTRACT }
  @precedence { FULL_TIME_CONST, DAY_TIME_CONST, SHORT_TIME_CONST, SPACECRAFT_TIME_CONST, CONCAT, SYMBOL_CONST }

  END_OF_LINE { "\n" }
}
